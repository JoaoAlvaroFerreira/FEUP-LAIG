

		
    for (var i = 0; i < children.length; i++)
        nodeNames.push(children[i].nodeName);
		
		for (var i = 0; i < children.length; i++) {
			
        if (children[i].nodeName != "primitive") {
                this.onXMLMinorError("unknown tag <" + children[i].nodeName + ">");
                continue;
            }
			
            var primitiveId = this.reader.getString(children[i], 'id');
            if (primitiveId == null)
                return "no ID defined for primitive";
			
			
            var grandChildren = children[i].children;
			 nodeNames = [];
            for (var j = 0; j < grandChildren.length; j++) {
                nodeNames.push(grandChildren[j].nodeName);
            }
			
			var primitiveNumber = possibleValues.findIndex(primitiveId);
			var primitiveDetails[];
			
			switch(primitiveNumber){
				
				case 0: //Zero
			
			var translateIndex = nodeNames.indexOf("translate");
            var rotateIndex  = nodeNames.indexOf("rotate");
            var scaleIndex = nodeNames.indexOf("scale");
 
			
			  
			  var translateCoordinates = [];
            if (translateIndex != -1) {
                // x
                var x = this.reader.getFloat(grandChildren[translateIndex], 'x');
                if (!(x != null && !isNaN(x)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    translateCoordinates.push(x);

                // y
                var y = this.reader.getFloat(grandChildren[translateIndex], 'y');
                if (!(y != null && !isNaN(y)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    translateCoordinates.push(y);

                // z
                var z = this.reader.getFloat(grandChildren[translateIndex], 'z');
                if (!(z != null && !isNaN(z)))
                    return "unable to parse z-coordinate of the primitive = " + primitiveId;
                else
                    translateCoordinates.push(z); 
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
			
			  var rotatingCoordinates = [];
            if (rotateIndex != -1) {
                // axis
                var axis = this.reader.getFloat(grandChildren[rotateIndex], 'axis');
                if (!(axis != null && !isNaN(axis)))
                    return "unable to parse axis of the primitive = " + primitiveId;
                else
                    rotatingCoordinates.push(axis);

                // angle
                var angle = this.reader.getFloat(grandChildren[rotateIndex], 'angle');
                if (!(angle != null && !isNaN(angle)))
                    return "unable to parse angle of the primitive = " + primitiveId;
                else
                    rotatingCoordinates.push(y);

            }
			
            else
                return "rotation coordinates undefined for ID = " + primitiveId;
			
				  var scaleCoordinates = [];
            if (scaleIndex != -1) {
                // x
                var x = this.reader.getFloat(grandChildren[scaleIndex], 'x');
                if (!(x != null && !isNaN(x)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    scaleCoordinates.push(x);

                // y
                var y = this.reader.getFloat(grandChildren[scaleIndex], 'y');
                if (!(y != null && !isNaN(y)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    scaleCoordinates.push(y);

                // z
                var z = this.reader.getFloat(grandChildren[scaleIndex], 'z');
                if (!(z != null && !isNaN(z)))
                    return "unable to parse z-coordinate of the primitive = " + primitiveId;
                else
                    scaleCoordinates.push(z); 
            }
			
            else
                return "scaling coordinates undefined for ID = " + primitiveId;
			
			this.primitiveDetails = [translateCoordinates, scaleCoordinates, rotatingCoordinates];
         
				//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				
				break;
				case 1: //Square
					
			var rectangleIndex = nodeNames.indexOf("rectangle");
			  var rectangleCoordinates = [];
            if (rectangleIndex != -1) {
                // x1
                var x1 = this.reader.getFloat(grandChildren[rectangleIndex], 'x1');
                if (!(x1 != null && !isNaN(x1)))
                    return "unable to parse x-coordinate  " 
                else
                    rectangleCoordinates.push(x1);

                // y1
                var y1 = this.reader.getFloat(grandChildren[rectangleIndex], 'y1');
                if (!(y1 != null && !isNaN(y1)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    rectangleCoordinates.push(y1);

                // x2
                var x2 = this.reader.getFloat(grandChildren[rectangleIndex], 'x2');
                if (!(x2 != null && !isNaN(x2)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    rectangleCoordinates.push(x2); 
				
				 // y2
                var y2 = this.reader.getFloat(grandChildren[rectangleIndex], 'y2');
                if (!(y2 != null && !isNaN(y2)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    rectangleCoordinates.push(y2);
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
			
				
				break;
				case 2: //TriangleRectangle
				
							var triangleIndex = nodeNames.indexOf("triangle");
			  var triangleCoordinates = [];
            if (triangleIndex != -1) {
                // x1
                var x1 = this.reader.getFloat(grandChildren[triangleIndex], 'x1');
                if (!(x1 != null && !isNaN(x1)))
                    return "unable to parse x-coordinate  " 
                else
                    triangleCoordinates.push(x1);

                // y1
                var y1 = this.reader.getFloat(grandChildren[triangleIndex], 'y1');
                if (!(y1 != null && !isNaN(y1)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(y1);

                // x2
                var x2 = this.reader.getFloat(grandChildren[triangleIndex], 'x2');
                if (!(x2 != null && !isNaN(x2)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(x2); 
				
				 // y2
                var y2 = this.reader.getFloat(grandChildren[triangleIndex], 'y2');
                if (!(y2 != null && !isNaN(y2)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(y2);
				
				// x3
                var x3 = this.reader.getFloat(grandChildren[triangleIndex], 'x3');
                if (!(x3 != null && !isNaN(x3)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(x3); 
				
				 // y3
                var y3 = this.reader.getFloat(grandChildren[triangleIndex], 'y3');
                if (!(y3 != null && !isNaN(y3)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(y3);
				
				//z1
                var z1 = this.reader.getFloat(grandChildren[triangleIndex], 'z1');
                if (!(z1 != null && !isNaN(z1)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(z1);
				//z2
                var z2 = this.reader.getFloat(grandChildren[triangleIndex], 'z2');
                if (!(z2 != null && !isNaN(z2)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(z2);
				//z3
                var z3 = this.reader.getFloat(grandChildren[triangleIndex], 'z3');
                if (!(z3 != null && !isNaN(z3)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    triangleCoordinates.push(z3);
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
								
				break:
				case 3: //Cylinder
				
				var cylinderIndex = nodeNames.indexOf("cylinder");
			  var cylinderCoordinates = [];
            if (cylinderIndex != -1) {
                // base
                var base = this.reader.getFloat(grandChildren[cylinderIndex], 'base');
                if (!(base != null && !isNaN(base)))
                    return "unable to parse x-coordinate  " 
                else
                    cylinderCoordinates.push(base);

                // top
                var top = this.reader.getFloat(grandChildren[cylinderIndex], 'top');
                if (!(top != null && !isNaN(top)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    cylinderCoordinates.push(top);

                // height
                var height = this.reader.getFloat(grandChildren[cylinderIndex], 'height');
                if (!(height != null && !isNaN(height)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    cylinderCoordinates.push(height); 
				
				 // slices
                var slices = this.reader.getFloat(grandChildren[cylinderIndex], 'slices');
                if (!(slices != null && !isNaN(slices)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    cylinderCoordinates.push(slices);
				
				 // stacks
                var stacks = this.reader.getFloat(grandChildren[cylinderIndex], 'stacks');
                if (!(stacks != null && !isNaN(stacks)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    cylinderCoordinates.push(stacks);
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
				
				break;
				case 4: //Sphere
				
				var sphereIndex = nodeNames.indexOf("sphere");
			  var sphereCoordinates = [];
			  
            if (sphereIndex != -1) {
				  // radius
                var radius = this.reader.getFloat(grandChildren[sphereIndex], 'radius');
                if (!(radius != null && !isNaN(radius)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    sphereCoordinates.push(radius); 
				
				 // slices
                var slices = this.reader.getFloat(grandChildren[sphereIndex], 'slices');
                if (!(slices != null && !isNaN(slices)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    sphereCoordinates.push(slices);
				
				 // stacks
                var stacks = this.reader.getFloat(grandChildren[sphereIndex], 'stacks');
                if (!(stacks != null && !isNaN(stacks)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    sphereCoordinates.push(stacks);
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
				break;
				case 5: //Torus
				
					
				var torusIndex = nodeNames.indexOf("torus");
			  var torusCoordinates = [];
			  
            if (torusIndex != -1) {
				
				  // inner
                var inner = this.reader.getFloat(grandChildren[torusIndex], 'inner');
                if (!(inner != null && !isNaN(inner)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    torusCoordinates.push(inner); 
				
				 // outer
                var outer = this.reader.getFloat(grandChildren[torusIndex], 'outer');
                if (!(outer != null && !isNaN(outer)))
                    return "unable to parse x-coordinate of the primitive = " + primitiveId;
                else
                    torusCoordinates.push(outer); 
				
				 // slices
                var slices = this.reader.getFloat(grandChildren[torusIndex], 'slices');
                if (!(slices != null && !isNaN(slices)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    torusCoordinates.push(slices);
				
				 // loops
                var loops = this.reader.getFloat(grandChildren[torusIndex], 'loops');
                if (!(loops != null && !isNaN(loops)))
                    return "unable to parse y-coordinate of the primitive = " + primitiveId;
                else
                    torusCoordinates.push(loops);
            }
			
            else
                return "translation coordinates undefined for ID = " + primitiveId;
				break:
			}
		
			
            
		
		
        this.log("Parsed primitives");
        return null;

	
    /**
     * Parses the <NODES> block.
     * @param {nodes block element} nodesNode
     */
    parseComponents(nodesNode) {
        
		var children = nodesNode.children;
		
		
        this.components = [];
        var numComponents = 0;

        var grandChildren = [];
        var nodeNames = [];
		
		
		
		
		
		
        this.log("Parsed nodes");
        return null;
    }

    /*
     * Callback to be executed on any read error, showing an error on the console.
     * @param {string} message
     */
    onXMLError(message) {
        console.error("XML Loading Error: " + message);
        this.loadedOk = false;
    }

    /**
     * Callback to be executed on any minor error, showing a warning on the console.
     * @param {string} message
     */
    onXMLMinorErro(message) {
        console.warn("Warning: " + message);
    }


    /**
     * Callback to be executed on any message.
     * @param {string} message
     */
    log(message) {
        console.log("   " + message);
    }

    /**
     * Displays the scene, processing each node, starting in the root node.
     */
    displayScene() { //displayScene(nodeName,tex1,Mat1)
		var material = Mat1;
		var texture = tex1;
		console.log(nodeName);
		
		if(nodeName != null){
			var node = this.graph[nodeName];
			
			if(node.material!=null)
				material = node.material;
			
			if(node.texture!=null)
				texture = node.texture;
			
		
		}
		
		this.multMatrix(node.mat);
		
		for(i= 0; i<node.descendents.length;i++){
			this.pushMatrix();
			this.DisplayScene(node.descendents[i],texture,material);
			this.popMatrix();
		}
		
        //desenhar Geometria
		
		if(node.primitive != null){
			
			//Aplicar material
			//Aplicar textura
			node.primitive.draw();
		}
		
    }